var {
  AST_NODE_TYPES: _AST_NODE_TYPES
} = require("@typescript-eslint/typescript-estree");

var {
  ESLintUtils,
  AST_NODE_TYPES,
  ASTUtils
} = require("@typescript-eslint/experimental-utils");

// -----------------------------------------------------------------------------
//      Attention: This file is generated by "yarn export-rules-and-config"
//                           Do not modify by hand
//              Run "yarn export-rules" to regenerate this file
// -----------------------------------------------------------------------------
const $b048fbd8fffa8a8cca119ee8df06474$export$configBaseline = {
  parser: "@typescript-eslint/parser",
  extends: ["eslint:recommended", "plugin:@typescript-eslint/eslint-recommended", "plugin:@typescript-eslint/recommended", "plugin:import/typescript", "prettier/@typescript-eslint"],
  plugins: ["@pinnacle0", "@typescript-eslint", "eslint-comments", "import", "react", "react-hooks"],
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: "module",
    ecmaFeatures: {
      jsx: true
    }
  },
  settings: {
    react: {
      version: "detect"
    }
  },
  rules: {
    "@pinnacle0/deep-nested-relative-imports": ["error"],
    "@pinnacle0/module-class-method-decorators": ["error"],
    "@pinnacle0/no-named-imports": ["error"],
    "@pinnacle0/react-component-default-props-typing": ["error"],
    "@pinnacle0/react-component-display-name": ["error"],
    "@pinnacle0/react-component-event-handler-naming": ["error"],
    "@pinnacle0/react-component-method-ordering": ["error"],
    "@pinnacle0/react-component-props-typing": ["error"],
    "@pinnacle0/react-component-state-member": ["error"],
    "@pinnacle0/restricted-imports": ["error"],
    "@pinnacle0/style-properties-type": ["error"],
    "@pinnacle0/ugly-relative-path": ["error"],
    "@pinnacle0/unnecessary-ending-index": ["error"],
    "@typescript-eslint/ban-types": "off",
    "@typescript-eslint/ban-ts-comment": "off",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/explicit-member-accessibility": ["error", {
      accessibility: "no-public"
    }],
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "@typescript-eslint/member-ordering": ["error", {
      default: {
        memberTypes: ["public-static-field", "protected-static-field", "private-static-field", "public-static-method", "protected-static-method", "private-static-method", "public-instance-field", "protected-instance-field", "private-instance-field", "public-abstract-field", "protected-abstract-field", "private-abstract-field", "public-constructor", "protected-constructor", "private-constructor", "public-instance-method", "protected-instance-method", "private-instance-method", "public-abstract-method", "protected-abstract-method", "private-abstract-method"],
        order: "as-written"
      }
    }],
    "@typescript-eslint/no-empty-function": "off",
    "@typescript-eslint/no-empty-interface": "off",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/no-inferrable-types": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "@typescript-eslint/no-unused-vars": "off",
    "@typescript-eslint/no-use-before-define": ["error", {
      functions: false,
      classes: true,
      variables: true,
      typedefs: false,
      ignoreTypeReferences: false
    }],
    "eslint-comments/no-unlimited-disable": ["error"],
    "eslint-comments/require-description": ["error", {
      ignore: ["eslint-enable", "eslint-env", "exported", "global", "globals"]
    }],
    "import/first": ["error"],
    "import/newline-after-import": ["error"],
    "import/no-anonymous-default-export": ["error", {
      allowArray: false,
      allowArrowFunction: false,
      allowAnonymousClass: false,
      allowAnonymousFunction: false,
      allowCallExpression: true,
      allowLiteral: false,
      allowObject: true
    }],
    "import/no-duplicates": ["error"],
    "import/no-dynamic-require": ["error"],
    "import/no-useless-path-segments": ["error", {
      noUselessIndex: false
    }],
    "import/prefer-default-export": "off",
    "no-console": ["error", {
      allow: ["info", "warn", "error"]
    }],
    "no-duplicate-imports": "off",
    // Use rule from eslint-plugin-import
    "no-useless-computed-key": ["error"],
    "no-useless-rename": ["error"],
    "no-var": ["error"],
    "object-shorthand": ["error"],
    "prefer-const": ["error"],
    "react/display-name": "off",
    "react/jsx-boolean-value": ["error", "never"],
    "react/jsx-curly-brace-presence": ["error", {
      props: "never",
      children: "ignore"
    }],
    "react/jsx-fragments": ["error", "element"],
    "react/jsx-no-target-blank": "off",
    "react/self-closing-comp": ["error", {
      component: true,
      html: true
    }],
    "react-hooks/exhaustive-deps": ["error"],
    "react-hooks/rules-of-hooks": ["error"],
    "require-yield": "off"
  }
};
const $f4b7eb3a52a0ff13cef45d76587c$export$configJest = {
  plugins: ["jest", "jest-dom", "testing-library"],
  env: {
    jest: true
  },
  rules: {
    // jest
    "jest/consistent-test-it": ["warn", {
      fn: "test",
      withinDescribe: "test"
    }],
    "jest/expect-expect": "off",
    // This is too annoying
    "jest/lowercase-name": ["warn", {
      ignore: ["describe"]
    }],
    "jest/no-alias-methods": ["warn"],
    "jest/no-commented-out-tests": ["warn"],
    "jest/no-deprecated-functions": ["warn"],
    "jest/no-duplicate-hooks": ["warn"],
    "jest/no-export": ["warn"],
    "jest/no-identical-title": ["warn"],
    "jest/no-jasmine-globals": ["warn"],
    "jest/no-mocks-import": ["warn"],
    "jest/no-restricted-matchers": ["warn", {
      resolves: "Use `expect(await promise)` instead."
    }],
    "jest/no-standalone-expect": ["warn"],
    "jest/no-test-prefixes": ["warn"],
    "jest/no-test-return-statement": ["warn"],
    "jest/prefer-called-with": ["warn"],
    "jest/prefer-expect-assertions": "off",
    // This is too annoying
    "jest/prefer-hooks-on-top": ["warn"],
    "jest/prefer-spy-on": ["warn"],
    "jest/prefer-strict-equal": ["warn"],
    "jest/prefer-to-be-null": ["warn"],
    "jest/prefer-to-be-undefined": ["warn"],
    "jest/prefer-to-contain": ["warn"],
    "jest/prefer-to-have-length": ["warn"],
    "jest/prefer-todo": ["warn"],
    "jest/require-top-level-describe": ["warn"],
    "jest/valid-expect": ["warn"],
    "jest/valid-title": "off",
    // This is too annoying
    // jest-dom
    "jest-dom/prefer-checked": ["warn"],
    "jest-dom/prefer-empty": ["warn"],
    "jest-dom/prefer-enabled-disabled": ["warn"],
    "jest-dom/prefer-focus": ["warn"],
    "jest-dom/prefer-required": ["warn"],
    "jest-dom/prefer-to-have-attribute": ["warn"],
    "jest-dom/prefer-to-have-text-content": ["warn"],
    // testing-library
    "testing-library/await-async-query": ["warn"],
    "testing-library/await-async-utils": ["warn"],
    "testing-library/no-await-sync-query": ["warn"],
    "testing-library/no-dom-import": ["warn", "react"],
    "testing-library/no-render-in-setup": ["warn"],
    "testing-library/prefer-find-by": ["warn"],
    "testing-library/prefer-presence-queries": ["warn"],
    "testing-library/prefer-screen-queries": ["warn"],
    "testing-library/prefer-wait-for": ["warn"]
  }
};
const $b9beafa9e1b7dcef71c78bdd94f576a$export$name = "deep-nested-relative-imports";
const $b9beafa9e1b7dcef71c78bdd94f576a$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $b9beafa9e1b7dcef71c78bdd94f576a$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "No deep nested relative imports",
      category: "Best Practices",
      recommended: "error"
    },
    messages: {
      deepNestedRelativeImports: 'no ["../../../"] imports'
    },
    schema: [{
      type: "object",
      additionalProperties: false
    }]
  },
  defaultOptions: [],
  create: context => {
    return {
      ImportDeclaration(node) {
        var _node$source$value;

        if ((_node$source$value = node.source.value) === null || _node$source$value === void 0 ? void 0 : _node$source$value.toString().startsWith("../../../")) {
          context.report({
            node,
            messageId: "deepNestedRelativeImports"
          });
        }
      }

    };
  }
});

function $c8412f06fa74bb76a30caaeeb19ba$export$isCoreFeOrCoreNativeModuleClass(context, classNode) {
  const {
    superClass
  } = classNode;
  const isClassNodeExtendsModule = (superClass === null || superClass === void 0 ? void 0 : superClass.type) === AST_NODE_TYPES.Identifier && superClass.name === "Module";

  if (isClassNodeExtendsModule) {
    var _ASTUtils$findVariabl;

    const allModuleVariableDefinitions = ((_ASTUtils$findVariabl = ASTUtils.findVariable(context.getScope(), "Module")) === null || _ASTUtils$findVariabl === void 0 ? void 0 : _ASTUtils$findVariabl.defs) || [];

    for (const _ of allModuleVariableDefinitions) {
      if (_ && _.type === "ImportBinding" && _.parent.type === AST_NODE_TYPES.ImportDeclaration && _.parent.source.type === AST_NODE_TYPES.Literal && typeof _.parent.source.value === "string" && ["core-fe", "core-native"].includes(_.parent.source.value)) {
        return true;
      }
    }
  }

  return false;
}

const $c569e2933c85b439b06058bdfe$export$name = "module-class-method-decorators";
const $c569e2933c85b439b06058bdfe$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $c569e2933c85b439b06058bdfe$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      onPrefixedMethodNotLifecycle: '"{{methodName}}" has prefix "on" and must be @Lifecycle()',
      lifecycleDecoratorOrder: "@Lifecycle() must be the first decorator",
      logDecoratorOrder: "@Log() must be the last decorator",
      lifecycleDecoratorWithLogDecorator: "@Log() should not be used with @Lifecycle()"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ClassDeclaration(node) {
        if ($c8412f06fa74bb76a30caaeeb19ba$export$isCoreFeOrCoreNativeModuleClass(context, node)) {
          $c569e2933c85b439b06058bdfe$var$checkClassBody(context, node.body);
        }
      },

      ClassExpression(node) {
        if ($c8412f06fa74bb76a30caaeeb19ba$export$isCoreFeOrCoreNativeModuleClass(context, node)) {
          $c569e2933c85b439b06058bdfe$var$checkClassBody(context, node.body);
        }
      }

    };
  }
});

function $c569e2933c85b439b06058bdfe$var$checkClassBody(context, classBody) {
  const methodList = classBody.body.map(classElement => {
    var _classElement$value, _classElement$value2;

    return classElement.type === AST_NODE_TYPES.MethodDefinition || classElement.type === AST_NODE_TYPES.TSAbstractMethodDefinition ? classElement : (classElement.type === AST_NODE_TYPES.ClassProperty || classElement.type === AST_NODE_TYPES.TSAbstractClassProperty) && (((_classElement$value = classElement.value) === null || _classElement$value === void 0 ? void 0 : _classElement$value.type) === AST_NODE_TYPES.ArrowFunctionExpression || ((_classElement$value2 = classElement.value) === null || _classElement$value2 === void 0 ? void 0 : _classElement$value2.type) === AST_NODE_TYPES.FunctionExpression) ? classElement : null;
  }).filter(_ => _ !== null);
  methodList.forEach(methodNode => {
    var _methodNode$decorator;

    if (methodNode.key.type !== AST_NODE_TYPES.Identifier) {
      return;
    }

    const methodName = methodNode.key.name;
    const methodDecorators = ((_methodNode$decorator = methodNode.decorators) === null || _methodNode$decorator === void 0 ? void 0 : _methodNode$decorator.map((decoratorNode, index) => {
      return decoratorNode.type === AST_NODE_TYPES.Decorator && decoratorNode.expression.type === AST_NODE_TYPES.CallExpression && decoratorNode.expression.callee.type === AST_NODE_TYPES.Identifier ? {
        index,
        decoratorNode,
        decoratorName: decoratorNode.expression.callee.name
      } : null;
    }).filter(_ => _ !== null)) || null;
    const lifecycleDecorator = (methodDecorators === null || methodDecorators === void 0 ? void 0 : methodDecorators.find(_ => _.decoratorName === "Lifecycle")) || null;
    const logDecorator = (methodDecorators === null || methodDecorators === void 0 ? void 0 : methodDecorators.find(_ => _.decoratorName === "Log")) || null;

    if (/^on([A-Z][\w]*)/.test(methodName) && methodName !== "onError" && lifecycleDecorator === null) {
      context.report({
        messageId: "onPrefixedMethodNotLifecycle",
        node: methodNode,
        data: {
          methodName
        },
        fix: fixer => fixer.insertTextBeforeRange(methodNode.range, "@Lifecycle()\n")
      });
    }

    if (methodDecorators !== null) {
      if (lifecycleDecorator !== null && lifecycleDecorator.index !== 0) {
        context.report({
          messageId: "lifecycleDecoratorOrder",
          node: lifecycleDecorator.decoratorNode,
          fix: fixer => [// (1) Remove @Lifecycle()
          fixer.removeRange(lifecycleDecorator.decoratorNode.range), // (2) Insert @Lifecycle() before first decorator
          fixer.insertTextBefore(methodDecorators[0].decoratorNode, "@Lifecycle()\n")]
        });
      }

      if (logDecorator !== null && logDecorator.index !== methodDecorators.length - 1) {
        context.report({
          messageId: "logDecoratorOrder",
          node: logDecorator.decoratorNode,
          fix: fixer => [// (1) Insert @Lifecycle() after last decorator
          fixer.insertTextAfter(methodDecorators[methodDecorators.length - 1].decoratorNode, "@Log()\n"), // (2) Remove @Log()
          fixer.removeRange(logDecorator.decoratorNode.range)]
        });
      }

      if (lifecycleDecorator !== null && logDecorator !== null) {
        context.report({
          messageId: "lifecycleDecoratorWithLogDecorator",
          node: logDecorator.decoratorNode,
          fix: fixer => fixer.removeRange(logDecorator.decoratorNode.range)
        });
      }
    }
  });
}

const $d93c668a9c3f8ae02c79262f76a38b38$export$name = "no-named-imports";
/**
 * import React, {useState} from "react";
 * React: ImportDefaultSpecifier
 * {useState}: ImportSpecifier
 * @param node
 * @return true if import statement contains any ImportSpecifier
 */

const $d93c668a9c3f8ae02c79262f76a38b38$var$hasImportSpecifier = node => {
  return node.specifiers.some(_ => _.type === AST_NODE_TYPES.ImportSpecifier);
};

const $d93c668a9c3f8ae02c79262f76a38b38$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $d93c668a9c3f8ae02c79262f76a38b38$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      noNamedImports: 'use [import {{name}} from "{{name}}" directly, no named imports.]]'
    },
    schema: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true
    }
  },
  defaultOptions: [],
  create: context => {
    const blacklist = new Set(context.options);
    const reportedNodes = new Set();
    return {
      ImportDeclaration(node) {
        var _node$source$value;

        const nodeSource = (_node$source$value = node.source.value) === null || _node$source$value === void 0 ? void 0 : _node$source$value.toString();

        if (!reportedNodes.has(node) && nodeSource && blacklist.has(nodeSource) && $d93c668a9c3f8ae02c79262f76a38b38$var$hasImportSpecifier(node)) {
          context.report({
            node,
            messageId: "noNamedImports",
            data: {
              name: nodeSource
            }
          });
          reportedNodes.add(node);
        }
      }

    };
  }
});

function $cf597e877de09fd1a582f9bf79969e1$export$isReactComponent({
  superClass
}) {
  var _superClass$property;

  return (superClass === null || superClass === void 0 ? void 0 : superClass.type) === _AST_NODE_TYPES.MemberExpression && superClass.object.type === _AST_NODE_TYPES.Identifier && superClass.object.name === "React" && ((_superClass$property = superClass.property) === null || _superClass$property === void 0 ? void 0 : _superClass$property.type) === _AST_NODE_TYPES.Identifier && ["Component", "PureComponent"].includes(superClass.property.name);
}

const $c77648ff827b842e41da38404e0b5c6$export$name = "react-component-default-props-typing";
const $c77648ff827b842e41da38404e0b5c6$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $c77648ff827b842e41da38404e0b5c6$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "Declare defaultProps with type Pick<Props> or PickOptional<Props>",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      incorrectDefaultPropsTypeAnnotation: "Annotate defaultProps with Pick/PickOptional of Props",
      incorrectPickOrPickOptionalTypeArguments: "Generic {{pickNodeRawName}} of defaultProps expects {{typeArgsExpected}} but received {{typeArgsReceived}}"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ClassDeclaration(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $c77648ff827b842e41da38404e0b5c6$var$checkComponentClass(context, node);
        }
      },

      ClassExpression(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $c77648ff827b842e41da38404e0b5c6$var$checkComponentClass(context, node);
        }
      }

    };
  }
});

function $c77648ff827b842e41da38404e0b5c6$var$checkComponentClass(context, classNode) {
  const classBody = classNode.body;
  classBody.body.forEach(_ => {
    var _defaultPropsNode$typ, _typeRef$typeParamete, _typeRef$typeParamete2;

    const defaultPropsNode = _.type === AST_NODE_TYPES.ClassProperty && _.key.type === AST_NODE_TYPES.Identifier && _.key.name === "defaultProps" && _.static && !_.declare ? _ : null;

    if (defaultPropsNode === null) {
      return;
    }

    const typeRef = ((_defaultPropsNode$typ = defaultPropsNode.typeAnnotation) === null || _defaultPropsNode$typ === void 0 ? void 0 : _defaultPropsNode$typ.typeAnnotation.type) === AST_NODE_TYPES.TSTypeReference ? defaultPropsNode.typeAnnotation.typeAnnotation : null;
    const pickNodeRawName = (typeRef === null || typeRef === void 0 ? void 0 : typeRef.typeName.type) === AST_NODE_TYPES.Identifier ? typeRef.typeName.name : null;
    const pickNodeTypeParamsLength = (typeRef === null || typeRef === void 0 ? void 0 : (_typeRef$typeParamete = typeRef.typeParameters) === null || _typeRef$typeParamete === void 0 ? void 0 : (_typeRef$typeParamete2 = _typeRef$typeParamete.params) === null || _typeRef$typeParamete2 === void 0 ? void 0 : _typeRef$typeParamete2.length) || 0;

    if (!(pickNodeRawName === "Pick" || pickNodeRawName === "PickOptional")) {
      context.report({
        messageId: "incorrectDefaultPropsTypeAnnotation",
        node: defaultPropsNode
      });
    } else if (!(pickNodeRawName === "Pick" && pickNodeTypeParamsLength === 2 || pickNodeRawName === "PickOptional" && pickNodeTypeParamsLength === 1)) {
      context.report({
        messageId: "incorrectPickOrPickOptionalTypeArguments",
        node: defaultPropsNode,
        data: {
          pickNodeRawName,
          typeArgsExpected: pickNodeRawName === "Pick" ? "2 type arguments" : "1 type argument",
          typeArgsReceived: `${pickNodeTypeParamsLength} ${typeRef ? `(${context.getSourceCode().getText(typeRef)})` : ""}`
        }
      });
    }
  });
}

function $eda4a7ccc121bb122f59520f4e5acad$export$findClosestParent(node, type) {
  return node.type === type ? node : node.parent && $eda4a7ccc121bb122f59520f4e5acad$export$findClosestParent(node.parent, type);
}

const $b16cdf2f4ad9034198589b5f8365b90f$export$name = "react-component-display-name"; // TODO: Add config option to decouple hardcoding of ReactUtil.memo

const $b16cdf2f4ad9034198589b5f8365b90f$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $b16cdf2f4ad9034198589b5f8365b90f$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      noDisplayName: "Add displayName",
      displayNameMismatch: "displayName must be the same as exported name",
      staticDisplayName: "displayName must be static"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ClassDeclaration(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          const componentName = node.id.name;
          $b16cdf2f4ad9034198589b5f8365b90f$var$checkClassProperties(context, node, componentName);
        }
      },

      ClassExpression(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          var _exportNode$declarati;

          const exportNode = $eda4a7ccc121bb122f59520f4e5acad$export$findClosestParent(node, AST_NODE_TYPES.ExportNamedDeclaration);

          if ((exportNode === null || exportNode === void 0 ? void 0 : (_exportNode$declarati = exportNode.declaration) === null || _exportNode$declarati === void 0 ? void 0 : _exportNode$declarati.type) === AST_NODE_TYPES.VariableDeclaration) {
            // export TestName =
            const firstDeclaration = exportNode.declaration.declarations[0];
            const exportName = ASTUtils.isIdentifier(firstDeclaration.id) && firstDeclaration.id.name; // exportName = "TestName"

            if (exportName) {
              $b16cdf2f4ad9034198589b5f8365b90f$var$checkClassProperties(context, node, exportName);
            }
          }
        }
      },

      VariableDeclarator(node) {
        var _node$init;

        if (node.id.type === AST_NODE_TYPES.Identifier && ((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === AST_NODE_TYPES.CallExpression && node.init.callee.type === AST_NODE_TYPES.MemberExpression && node.init.callee.object.type === AST_NODE_TYPES.Identifier && node.init.callee.object.name === "ReactUtil" && node.init.callee.property.type === AST_NODE_TYPES.Identifier && node.init.callee.property.name === "memo") {
          const exportedName = node.id.name;

          if (!(node.init.arguments[0].type === AST_NODE_TYPES.Literal && node.init.arguments[0].value === exportedName)) {
            context.report({
              messageId: "displayNameMismatch",
              node,
              fix: fixer => fixer.replaceText(node.init["arguments"][0], `"${exportedName}"`)
            });
          }
        }
      }

    };
  }
});

function $b16cdf2f4ad9034198589b5f8365b90f$var$checkClassProperties(context, classNode, displayName) {
  const {
    body
  } = classNode;
  const displayNameNode = body.body.find(_ => _.type === AST_NODE_TYPES.ClassProperty && ASTUtils.isIdentifier(_.key) && _.key.name === "displayName");

  if (displayNameNode) {
    var _displayNameNode$valu;

    // Check if displayName is static
    if (!displayNameNode.static) {
      context.report({
        messageId: "staticDisplayName",
        node: displayNameNode,
        fix: fixer => fixer.insertTextBefore(displayNameNode, "static ")
      });
    } // Check if literal displayName matches


    if (((_displayNameNode$valu = displayNameNode.value) === null || _displayNameNode$valu === void 0 ? void 0 : _displayNameNode$valu.type) === AST_NODE_TYPES.Literal && displayNameNode.value.value !== displayName) {
      context.report({
        messageId: "displayNameMismatch",
        node: displayNameNode,
        fix: fixer => fixer.replaceText(displayNameNode.value, `"${displayName}"`)
      });
    }
  } else {
    // Missing displayName
    // Class body starts with brace, + 1 to insert after brace.
    context.report({
      messageId: "noDisplayName",
      node: classNode.superClass,
      fix: fixer => fixer.insertTextAfterRange([body.range[0] + 1, body.range[0] + 1], `\nstatic displayName = "${displayName}";\n`)
    });
  }
}

function $e9744fe6117f7aa069b44e61908633c$export$getClassElementCategory(classElement) {
  var _classElement$value, _classElement$value2;

  switch (classElement.type) {
    case AST_NODE_TYPES.MethodDefinition:
    case AST_NODE_TYPES.TSAbstractMethodDefinition:
      if (classElement.kind === "constructor") {
        return "constructor";
      }

      return "method-or-arrow-function";

    case AST_NODE_TYPES.ClassProperty:
    case AST_NODE_TYPES.TSAbstractClassProperty:
      if (((_classElement$value = classElement.value) === null || _classElement$value === void 0 ? void 0 : _classElement$value.type) === AST_NODE_TYPES.ArrowFunctionExpression || ((_classElement$value2 = classElement.value) === null || _classElement$value2 === void 0 ? void 0 : _classElement$value2.type) === AST_NODE_TYPES.FunctionExpression) {
        return "method-or-arrow-function"; // Treat arrow function expressions as methods
      }

      return "field";

    case AST_NODE_TYPES.TSIndexSignature:
      return "field";
    // Don't care what this is
  }
}

function $a835fbed79109a489b1b155a466df64$export$getClassElementName(classElement) {
  switch (classElement.type) {
    case AST_NODE_TYPES.TSIndexSignature:
      return null;
    // Don't know what this is, just ignore it

    case AST_NODE_TYPES.ClassProperty:
    case AST_NODE_TYPES.MethodDefinition:
    case AST_NODE_TYPES.TSAbstractClassProperty:
    case AST_NODE_TYPES.TSAbstractMethodDefinition:
      if (classElement.key.type === AST_NODE_TYPES.Identifier) {
        return classElement.key.name;
      }

      return null;
    // Don't care about PropertyNameNonComputed keys of type (StringLiteral | NumerLiteral), or PropertyNameComputed keys
  }
}

const $e265d50e76a3dd7bee8f1bf7b3cc47ca$export$name = "react-component-event-handler-naming";
const $e265d50e76a3dd7bee8f1bf7b3cc47ca$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $e265d50e76a3dd7bee8f1bf7b3cc47ca$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "Use onXxxChange instead of onChangeXxx, and onXxxClick instead of onClickXxx for event handler naming",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      reactComponentChangeHandlerNaming: 'Name change handlers "{{suggestedName}}" instead of "{{methodName}}"',
      reactComponentClickHandlerNaming: 'Name click handlers "{{suggestedName}}" instead of "{{methodName}}"'
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ClassDeclaration(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $e265d50e76a3dd7bee8f1bf7b3cc47ca$var$checkClassBody(context, node.body);
        }
      },

      ClassExpression(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $e265d50e76a3dd7bee8f1bf7b3cc47ca$var$checkClassBody(context, node.body);
        }
      }

    };
  }
});
const $e265d50e76a3dd7bee8f1bf7b3cc47ca$var$incorrectOnChangeRegExp = /^onChange(\w+)$/;
const $e265d50e76a3dd7bee8f1bf7b3cc47ca$var$incorrectOnClickRegExp = /^onClick(\w+)$/;

function $e265d50e76a3dd7bee8f1bf7b3cc47ca$var$checkClassBody(context, classBody) {
  classBody.body.forEach(classElement => {
    if (classElement.type === AST_NODE_TYPES.TSIndexSignature) {
      return; // Allow type narrowing on classElement.type
    }

    const methodName = $a835fbed79109a489b1b155a466df64$export$getClassElementName(classElement);
    const category = $e9744fe6117f7aa069b44e61908633c$export$getClassElementCategory(classElement);

    if (methodName && category === "method-or-arrow-function") {
      const reportError = (messageId, suggestedName) => {
        context.report({
          messageId,
          node: classElement,
          data: {
            suggestedName,
            methodName
          },
          fix: classElement.key.type !== AST_NODE_TYPES.Identifier ? null : fixer => fixer.replaceText(classElement.key, suggestedName)
        });
      };

      if ($e265d50e76a3dd7bee8f1bf7b3cc47ca$var$incorrectOnChangeRegExp.test(methodName)) {
        const suggestedName = methodName.replace($e265d50e76a3dd7bee8f1bf7b3cc47ca$var$incorrectOnChangeRegExp, (_, eventName) => `on${eventName[0].toUpperCase()}${eventName.slice(1)}Change`);
        reportError("reactComponentChangeHandlerNaming", suggestedName);
      } else if ($e265d50e76a3dd7bee8f1bf7b3cc47ca$var$incorrectOnClickRegExp.test(methodName)) {
        const suggestedName = methodName.replace($e265d50e76a3dd7bee8f1bf7b3cc47ca$var$incorrectOnClickRegExp, (_, eventName) => `on${eventName[0].toUpperCase()}${eventName.slice(1)}Click`);
        reportError("reactComponentClickHandlerNaming", suggestedName);
      }
    }
  });
}

function $a8a09f82ec81165297157b7e6f973f4c$export$isClassElementAbstract(classElement) {
  switch (classElement.type) {
    case AST_NODE_TYPES.ClassProperty:
    case AST_NODE_TYPES.MethodDefinition:
    case AST_NODE_TYPES.TSIndexSignature:
      return false;

    case AST_NODE_TYPES.TSAbstractClassProperty:
    case AST_NODE_TYPES.TSAbstractMethodDefinition:
      return true;
  }
}

const $b01fde904eb3892f02e8b26730b520$var$lifeCycleMethodList = ["render", "componentDidMount", "componentDidUpdate", "componentWillUnmount", "shouldComponentUpdate", "getDerivedStateFromProps", "getSnapshotBeforeUpdate" // prettier-format-preserve
];

function $b01fde904eb3892f02e8b26730b520$export$isReactComponentLifecyleMethod(methodName) {
  return $b01fde904eb3892f02e8b26730b520$var$lifeCycleMethodList.includes(methodName);
}

const $ddf53ec5000e58e98d44b1532ff0b92$export$name = "react-component-method-ordering";
const $ddf53ec5000e58e98d44b1532ff0b92$export$methodOrderCheckers = [{
  type: "lifecyle-method",
  validator: function isLifecycleMethodExceptRender(methodName) {
    return $b01fde904eb3892f02e8b26730b520$export$isReactComponentLifecyleMethod(methodName) && methodName !== "render";
  }
}, {
  type: "custom-function",
  validator: function isCustomFunction(methodName) {
    return [/^on[A-Z].*/.test(methodName), /^render.*/.test(methodName)].every(_ => _ === false);
  }
}, {
  type: "event-handler",
  validator: function isEventHandler(methodName) {
    return /^on[A-Z].*/.test(methodName);
  }
}, {
  type: "custom-render-function",
  validator: function isCustomRenderFunction(methodName) {
    return /^render[A-Z].*/.test(methodName);
  }
}, {
  type: "react-render-function",
  validator: function isReactRenderFunction(methodName) {
    return /^render$/.test(methodName);
  }
}];
const $ddf53ec5000e58e98d44b1532ff0b92$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $ddf53ec5000e58e98d44b1532ff0b92$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "Order react component methods according to pinnacle react component guideline",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      reactComponentMethodOrdering: "Method [{{methodName}}] is a {{methodType}}, and should be placed before {{prevCheckerType}}"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ClassDeclaration(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $ddf53ec5000e58e98d44b1532ff0b92$var$checkClassBody(context, node.body);
        }
      },

      ClassExpression(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $ddf53ec5000e58e98d44b1532ff0b92$var$checkClassBody(context, node.body);
        }
      }

    };
  }
});

function $ddf53ec5000e58e98d44b1532ff0b92$var$checkClassBody(context, classBody) {
  const methodList = $ddf53ec5000e58e98d44b1532ff0b92$var$getClassMethods(classBody);
  const groupedMethods = methodList.reduce((prev, method) => {
    const group = (prev[method.groupLabel] || []).concat([method]);
    return Object.assign(prev, {
      [method.groupLabel]: group
    });
  }, {});
  Object.entries(groupedMethods).forEach(([groupLabel, methodGroup]) => {
    $ddf53ec5000e58e98d44b1532ff0b92$var$checkClassMethodList(context, methodGroup);
  });
}

function $ddf53ec5000e58e98d44b1532ff0b92$var$getClassMethods(classBody) {
  return classBody.body.map((classElement, index) => {
    const name = $a835fbed79109a489b1b155a466df64$export$getClassElementName(classElement);

    if (name === null) {
      return null;
    }

    const category = $e9744fe6117f7aa069b44e61908633c$export$getClassElementCategory(classElement);

    if (category !== "method-or-arrow-function") {
      return null;
    }

    const isAbstract = $a8a09f82ec81165297157b7e6f973f4c$export$isClassElementAbstract(classElement);
    const isStatic = classElement.static || false;
    const accessibility = classElement.accessibility || "public";
    const groupLabel = [accessibility, isStatic ? "static" : isAbstract ? "abstract" : "instance", "method"].filter(_ => _ !== null).join("-");
    return {
      index,
      classElement,
      groupLabel,
      name,
      category,
      isAbstract,
      isStatic,
      accessibility
    };
  }).filter(_ => _ !== null);
}

function $ddf53ec5000e58e98d44b1532ff0b92$var$checkClassMethodList(context, classMethodList) {
  let prevCheckerIndex = 0;

  for (const wrappedMethod of classMethodList) {
    const currentCheckerIndex = $ddf53ec5000e58e98d44b1532ff0b92$export$methodOrderCheckers.findIndex(_ => _.validator(wrappedMethod.name));

    if (currentCheckerIndex === -1) {
      continue;
    }

    if (currentCheckerIndex < prevCheckerIndex) {
      context.report({
        messageId: "reactComponentMethodOrdering",
        node: wrappedMethod.classElement,
        data: {
          methodName: wrappedMethod.name,
          prevCheckerType: $ddf53ec5000e58e98d44b1532ff0b92$export$methodOrderCheckers[prevCheckerIndex].type,
          methodType: $ddf53ec5000e58e98d44b1532ff0b92$export$methodOrderCheckers[currentCheckerIndex].type
        }
      });
    } else {
      prevCheckerIndex = currentCheckerIndex;
    }
  }
}

function $d31c8b9fb4138865f41223d0b5674$export$getRawGenericsOfSuperClass(context, classNode) {
  const typeNode = classNode.superTypeParameters || null;

  if (typeNode) {
    const sourceCode = context.getSourceCode();
    const rawGenerics = typeNode.params.map(typeParam => sourceCode.getText(typeParam));

    if (rawGenerics.length > 0) {
      return rawGenerics;
    }
  }

  return null;
}

const $cf44290c019e07d3cf4278e919ba4d5a$export$name = "react-component-default-props-typing";
const $cf44290c019e07d3cf4278e919ba4d5a$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $cf44290c019e07d3cf4278e919ba4d5a$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "Specify generic type of React.Component or React.PureComponent when declaring a class component",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      reactComponentPropsTyping: "Declare React.{{componentOrPureComponent}} with type annotation parameters"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ClassDeclaration(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $cf44290c019e07d3cf4278e919ba4d5a$var$checkComponentClass(context, node);
        }
      },

      ClassExpression(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $cf44290c019e07d3cf4278e919ba4d5a$var$checkComponentClass(context, node);
        }
      }

    };
  }
});

function $cf44290c019e07d3cf4278e919ba4d5a$var$checkComponentClass(context, classNode) {
  var _getRawGenericsOfSupe;

  const propsGenericAnnotation = ((_getRawGenericsOfSupe = $d31c8b9fb4138865f41223d0b5674$export$getRawGenericsOfSuperClass(context, classNode)) === null || _getRawGenericsOfSupe === void 0 ? void 0 : _getRawGenericsOfSupe[0]) || null;

  if (propsGenericAnnotation === null) {
    const componentOrPureComponent = classNode.superClass.property.name === "Component" ? "Component" : "PureComponent";
    context.report({
      messageId: "reactComponentPropsTyping",
      node: classNode.superClass,
      data: {
        componentOrPureComponent
      }
    });
  }
}

const $ae4e911c47f982c69c47b77ff102dc7f$export$name = "react-component-state-member";
const $ae4e911c47f982c69c47b77ff102dc7f$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $ae4e911c47f982c69c47b77ff102dc7f$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "Initialize component state inside constructor instead of using class field declaration",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      reactComponentStateMember: "Put state initialization inside constructor"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ClassDeclaration(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $ae4e911c47f982c69c47b77ff102dc7f$var$checkClassBody(context, node, node.body);
        }
      },

      ClassExpression(node) {
        if ($cf597e877de09fd1a582f9bf79969e1$export$isReactComponent(node)) {
          $ae4e911c47f982c69c47b77ff102dc7f$var$checkClassBody(context, node, node.body);
        }
      }

    };
  }
});

function $ae4e911c47f982c69c47b77ff102dc7f$var$checkClassBody(context, classNode, classBody) {
  classBody.body.forEach(classElement => {
    if (classElement.type !== AST_NODE_TYPES.ClassProperty && classElement.type !== AST_NODE_TYPES.TSAbstractClassProperty) {
      return; // Allow type narrowing on classElement.type
    }

    if (!classElement.static && !classElement.declare && $a835fbed79109a489b1b155a466df64$export$getClassElementName(classElement) === "state") {
      var _classBody$body$find, _getRawGenericsOfSupe;

      const stateDeclarationSourceCode = context.getSourceCode().getText(classElement);
      const constructorEndLocation = (_classBody$body$find = classBody.body.find(_ => $e9744fe6117f7aa069b44e61908633c$export$getClassElementCategory(_) === "constructor")) === null || _classBody$body$find === void 0 ? void 0 : _classBody$body$find.range[1];
      const propsGenericAnnotation = ((_getRawGenericsOfSupe = $d31c8b9fb4138865f41223d0b5674$export$getRawGenericsOfSuperClass(context, classNode)) === null || _getRawGenericsOfSupe === void 0 ? void 0 : _getRawGenericsOfSupe[0]) || null;
      context.report({
        messageId: "reactComponentStateMember",
        node: classElement,
        fix: fixer => constructorEndLocation ? [fixer.insertTextAfterRange([constructorEndLocation - 1, constructorEndLocation - 1], `this.${stateDeclarationSourceCode}`), fixer.removeRange(classElement.range)] : fixer.replaceTextRange(classElement.range, `constructor(props${propsGenericAnnotation ? `: ${propsGenericAnnotation}` : ""}) {this.${stateDeclarationSourceCode}}`)
      });
    }
  });
}

const $ab2bc68c5524b478e4bbc95a12d5d9d$export$name = "restricted-imports";
const $ab2bc68c5524b478e4bbc95a12d5d9d$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $ab2bc68c5524b478e4bbc95a12d5d9d$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: `Whitelists specified import by folder path. Example: rule: ["error", {"packages": ["antd"], "path": "shared"}] Will only allow antd imports in file which path includes shared. `,
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      restrictedImports: "{{nodeSource}} can only be imported in {{path}}"
    },
    schema: {
      type: "array",
      items: {
        $ref: "#/definitions/WhitelistConfig"
      },
      definitions: {
        WhitelistConfig: {
          type: "object",
          additionalProperties: false,
          properties: {
            path: {
              type: "string"
            },
            packages: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          required: ["packages", "path"],
          title: "WhitelistConfig"
        }
      }
    }
  },
  defaultOptions: [],
  create: context => {
    return {
      ImportDeclaration(node) {
        if (context.options.length > 0) {
          var _context$options$find;

          const fileName = context.getFilename();
          const nodeSource = node.source.value.toString();
          const whitelistPath = (_context$options$find = context.options.find(_ => _.packages.includes(nodeSource))) === null || _context$options$find === void 0 ? void 0 : _context$options$find.path;

          if (whitelistPath && !fileName.includes(`/${whitelistPath}/`)) {
            context.report({
              node,
              messageId: "restrictedImports",
              data: {
                path: whitelistPath,
                nodeSource
              }
            });
          }
        }
      }

    };
  }
});
const $d474cfb48bc3547da862647091744a0$export$name = "style-properties-type";
const $d474cfb48bc3547da862647091744a0$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $d474cfb48bc3547da862647091744a0$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      stylePropertiesType: "React.CSSProperties' name must end with 'Style', e.g: containerStyle, inputStyle"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      VariableDeclarator(node) {
        if (ASTUtils.isIdentifier(node.id) && node.id.typeAnnotation && node.id.typeAnnotation.typeAnnotation.type === AST_NODE_TYPES.TSTypeReference) {
          if ($d474cfb48bc3547da862647091744a0$var$isCSSProperties(node.id.typeAnnotation.typeAnnotation) && !node.id.name.endsWith("Style")) {
            context.report({
              node: node.id,
              messageId: "stylePropertiesType",
              fix: fixer => fixer.insertTextAfterRange([node.id.range[0], node.id.range[0] + node.id.name.length], "Style")
            });
          }
        }
      }

    };
  }
});

function $d474cfb48bc3547da862647091744a0$var$isCSSProperties(node) {
  return node.typeName.type === AST_NODE_TYPES.Identifier && node.typeName.name === "CSSProperties" || node.typeName.type === AST_NODE_TYPES.TSQualifiedName && ASTUtils.isIdentifier(node.typeName.left) && node.typeName.left.name === "React" && ASTUtils.isIdentifier(node.typeName.right) && node.typeName.right.name === "CSSProperties";
}

const $c6d81e5ca0dc11a62ad41b3c5fc13$export$name = "ugly-relative-path";
const $c6d81e5ca0dc11a62ad41b3c5fc13$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $c6d81e5ca0dc11a62ad41b3c5fc13$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "No ugly relative path imports",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      uglyRelativePath: 'no ["."], [".."] imports'
    },
    schema: [{
      type: "object",
      additionalProperties: false
    }]
  },
  defaultOptions: [],
  create: context => {
    return {
      ImportDeclaration(node) {
        var _node$source$value;

        if ((_node$source$value = node.source.value) === null || _node$source$value === void 0 ? void 0 : _node$source$value.toString().match(/^(\.\.?\/?)+$/)) {
          context.report({
            node,
            messageId: "uglyRelativePath"
          });
        }
      }

    };
  }
});
const $f9d37ac930ce5f42a834fa5d42448b15$export$name = "unnecessary-ending-index";
const $f9d37ac930ce5f42a834fa5d42448b15$export$rule = ESLintUtils.RuleCreator(name => name)({
  name: $f9d37ac930ce5f42a834fa5d42448b15$export$name,
  meta: {
    type: "suggestion",
    docs: {
      description: "No index at the end of import statements",
      category: "Best Practices",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      unnecessaryEndingIndex: "unnecessary ending index"
    },
    schema: []
  },
  defaultOptions: [],
  create: context => {
    return {
      ImportDeclaration(node) {
        var _node$source$value;

        const importSourcePath = (_node$source$value = node.source.value) === null || _node$source$value === void 0 ? void 0 : _node$source$value.toString();

        if (importSourcePath && importSourcePath.endsWith("/index") && !$f9d37ac930ce5f42a834fa5d42448b15$var$isAllowedImportIndexPath(importSourcePath)) {
          context.report({
            node,
            messageId: "unnecessaryEndingIndex",
            fix: fixer => fixer.replaceText(node.source, node.source.raw.replace(/\/index"/, '"'))
          });
        }
      }

    };
  }
});

function $f9d37ac930ce5f42a834fa5d42448b15$var$isAllowedImportIndexPath(importSourcePath) {
  return importSourcePath === "./index" || /^(\.\.\/)+index$/.test(importSourcePath);
}

const $ddb946df26ed3e2e757e80f2b4242de$export$allRules = {
  "deep-nested-relative-imports": $b9beafa9e1b7dcef71c78bdd94f576a$export$rule,
  "module-class-method-decorators": $c569e2933c85b439b06058bdfe$export$rule,
  "no-named-imports": $d93c668a9c3f8ae02c79262f76a38b38$export$rule,
  "react-component-default-props-typing": $c77648ff827b842e41da38404e0b5c6$export$rule,
  "react-component-display-name": $b16cdf2f4ad9034198589b5f8365b90f$export$rule,
  "react-component-event-handler-naming": $e265d50e76a3dd7bee8f1bf7b3cc47ca$export$rule,
  "react-component-method-ordering": $ddf53ec5000e58e98d44b1532ff0b92$export$rule,
  "react-component-props-typing": $cf44290c019e07d3cf4278e919ba4d5a$export$rule,
  "react-component-state-member": $ae4e911c47f982c69c47b77ff102dc7f$export$rule,
  "restricted-imports": $ab2bc68c5524b478e4bbc95a12d5d9d$export$rule,
  "style-properties-type": $d474cfb48bc3547da862647091744a0$export$rule,
  "ugly-relative-path": $c6d81e5ca0dc11a62ad41b3c5fc13$export$rule,
  "unnecessary-ending-index": $f9d37ac930ce5f42a834fa5d42448b15$export$rule
};
const rules = $ddb946df26ed3e2e757e80f2b4242de$export$allRules;
exports.rules = rules;
const configs = {
  baseline: $b048fbd8fffa8a8cca119ee8df06474$export$configBaseline,
  jest: $f4b7eb3a52a0ff13cef45d76587c$export$configJest
};
exports.configs = configs;
//# sourceMappingURL=index.js.map
